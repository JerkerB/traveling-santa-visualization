<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Reaktor santa challenge</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/99/three.min.js"></script>
    <script>
      var EARTH_RADIUS = 67.38;

      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      var renderer = new THREE.WebGLRenderer();
      camera.up.set(0, 0, 1);

      var axesHelper = new THREE.AxesHelper(100);
      scene.add(axesHelper);

      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      var group = new THREE.Group();
      var earthMesh = createEarthMesh();
      var korvatunturiMesh = createKorvatunturiMesh();
      group.add(earthMesh, korvatunturiMesh);
      getGifstFromNiceList().then(gifts => {
        mesh = createGiftMesh(gifts);
        mesh.name = 'gifts';
        group.add(mesh);
      });
      scene.add(group);

      camera.position.z = 300;
      render();

      var rotation = 0.1;

      function render() {
        requestAnimationFrame(render);
        group.rotateOnWorldAxis(new THREE.Vector3(1, 1, 0), 0.01);
        renderer.render(scene, camera);
      }

      function deliverPresent(giftIndex) {
        var giftColorAttribute = group.getObjectByName('gifts').geometry.attributes.color;
        giftColorAttribute.array[giftIndex * 3] = 0;
        giftColorAttribute.array[giftIndex * 3 + 1] = 0;
        giftColorAttribute.array[giftIndex * 3 + 2] = 0;
        giftColorAttribute.needsUpdate;
      }

      function LLAtoECEF(radius, latitude, longitude, alt) {
        var flattening = 0;
        var latitudeAtMeanSeaLevel = Math.atan(Math.pow(1 - flattening, 2) * Math.tan(latitude));
        var x = radius * Math.cos(latitudeAtMeanSeaLevel) * Math.cos(longitude) + alt * Math.cos(latitude) * Math.cos(longitude);
        var y = radius * Math.cos(latitudeAtMeanSeaLevel) * Math.sin(longitude) + alt * Math.cos(latitude) * Math.sin(longitude);
        var z = radius * Math.sin(latitudeAtMeanSeaLevel) + alt * Math.sin(latitude);
        return new THREE.Vector3(-x, -z, -y);
      }

      function createEarthMesh() {
        var segments = 30;
        var rings = 30;
        var geometry = new THREE.SphereGeometry(EARTH_RADIUS, segments, rings);
        var material = new THREE.MeshBasicMaterial();
        material.map = new THREE.TextureLoader().load('./earthmap1k.jpg');
        var earthMesh = new THREE.Mesh(geometry, material);

        return new THREE.Mesh(geometry, material);
      }

      function createKorvatunturiMesh() {
        return createPointMeshFromCoordinate(30, 0x0000ff, 68.073611, 29.315278);
      }

      function createCubeMeshFromCoordinate(width, height, depth, color, latitude, longitude) {
        var geometry = new THREE.BoxGeometry(width, height, depth);
        var material = new THREE.MeshBasicMaterial({ color: color });
        var coordinateMesh = new THREE.Mesh(geometry, material);
        var pos = LLAtoECEF(EARTH_RADIUS, latitude, longitude, 0);
        coordinateMesh.position.set(pos.x, pos.y, pos.z);
        return coordinateMesh;
      }

      function createPointMeshFromCoordinate(size, color, latitude, longitude) {
        var geometry = new THREE.Geometry();
        geometry.vertices.push(new THREE.Vector3());
        var material = new THREE.PointsMaterial({ size: size, sizeAttenuation: false, color: color });
        var coordinateMesh = new THREE.Points(geometry, material);
        var pos = LLAtoECEF(EARTH_RADIUS, latitude, longitude, 0);
        coordinateMesh.position.set(pos.x, pos.y, pos.z);
        return coordinateMesh;
      }

      function readFile(pathToFile) {
        return fetch(pathToFile)
          .then(response => response.text())
          .then(text => {
            return text;
          });
      }

      async function getGifstFromNiceList() {
        var text = await readFile('nicelist.txt');
        var gifts = text.split('\n').map(x => {
          var props = x.split(';');
          return { id: props[0], lat: props[1], lon: props[2], weight: props[3] };
        });
        return gifts;
      }

      function createGiftMesh(gifts) {
        var geometry = new THREE.BufferGeometry();
        var vertices = new Float32Array(gifts.length * 3);
        var colors = new Float32Array(gifts.length * 3);
        var color = new THREE.Color(0xff0000);
        gifts.forEach((gift, giftIndex) => {
          var pos = LLAtoECEF(EARTH_RADIUS, gift.lat, gift.lon, 0);
          verticeIndex = giftIndex * 3;
          vertices[verticeIndex] = pos.x;
          vertices[verticeIndex + 1] = pos.y;
          vertices[verticeIndex + 2] = pos.z;
          colors[verticeIndex] = color.r;
          colors[verticeIndex + 1] = color.g;
          colors[verticeIndex + 2] = color.b;
        });
        geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
        geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
        var material = new THREE.PointsMaterial({ size: 2, vertexColors: THREE.VertexColors });
        return new THREE.Points(geometry, material);
      }
    </script>
  </body>
</html>
